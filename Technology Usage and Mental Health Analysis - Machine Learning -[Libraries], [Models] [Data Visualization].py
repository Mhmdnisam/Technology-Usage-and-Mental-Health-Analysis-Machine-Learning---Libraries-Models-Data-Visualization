# -*- coding: utf-8 -*-
"""Welcome to Colaboratory

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb
"""

#The dataset includes columns that track an individual's daily technology usage and mental health indicators. Here’s what’s included:

#User_ID: A unique identifier for each participant.
#Age: The age of the participant.
#Daily_Screen_Time (hours): Average daily screen time in hours.
#Mental_Health_Score (1-10): Self-reported mental health score, where 1 is poor, and 10 is excellent.
#Stress_Level (1-10): Self-reported stress level, where 1 is very low, and 10 is very high.
#Sleep_Quality (1-10): Self-reported sleep quality score.

#importing libraries:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

#Data collection and exploration:
df=pd.read_csv('mental_health_and_technology_usage_2024.csv')

data_types = df.dtypes
print(data_types)

#Checking Duplicates
duplicates = df.duplicated().sum()
print(f"Number of duplicate rows: {duplicates}")

#View the First Few Rows
df.head()

df.info()

df.describe()

df.describe()

df.columns

#checking for missing values
missing_values = df.isnull().sum()
print(missing_values)

#Dropping Rows or Columns with Missing Values
# Drop rows with any missing values
df_cleaned_rows = df.dropna()
# Drop columns with any missing values
df_cleaned_cols = df.dropna(axis=1)

#Breakdown

import warnings
warnings.filterwarnings('ignore')

#1. How does age distribute among the participants?

plt.figure(figsize=(10, 6))
sns.histplot(df['Age'], kde=True, color='blue') #kernel density estimation (KDE)
plt.title('Age Distribution')
plt.xlabel('Age')
plt.ylabel('Frequency')
plt.show()

#2. What is the gender distribution?

gender_counts = df['Gender'].value_counts()
print(gender_counts)
plt.figure(figsize=(6, 6))
plt.pie(gender_counts.values, labels=gender_counts.index, autopct="%1.1f%%")
plt.title('Gender Distribution')
plt.show()

#3. What is the distribution of mental health status among the participants?

fig = px.pie(df, names='Mental_Health_Status', title='Mental Health Status Distribution')
fig.update_layout(margin=dict(t=0, b=0, l=0, r=0))
fig.show()

4. How is access to support systems distributed among participants?

fig = px.pie(df, names='Support_Systems_Access', title='Support Systems Access Distribution')
fig.update_layout(margin=dict(t=0, b=0, l=0, r=0))
fig.show()

5. What is the distribution of age groups in the dataset?

df['Age_Group'] = pd.cut(df['Age'], bins=[0, 18, 30, 40, 50, 60, 100],
                                     labels=['<18', '18-30', '30-40', '40-50', '50-60', '60+'])

fig = px.pie(df, names='Age_Group', title='Age Group Distribution')
fig.update_layout(margin=dict(t=0, b=0, l=0, r=0))
fig.show()

6. Which age group reports the highest screen time?

# Calculating Average Screen Time by Age Group (Grouping and Aggregation):
avg_screen_time = df.groupby('Age')['Screen_Time_Hours'].mean()

plt.figure(figsize=(10,6))
sns.barplot(x=avg_screen_time.index, y=avg_screen_time.values)
plt.title('Average Screen Time by Age Group')
plt.xlabel('Age')
plt.ylabel('Screen Time (Hours)')
plt.xticks(rotation=90)
plt.show()

#7. What is the distribution of stress levels across different age groups?

# Calculating the proportion of each stress level by age group
stress_level_age = df.groupby(['Age', 'Stress_Level']).size().unstack().fillna(0)

# Normalizing to get proportions
stress_level_age = stress_level_age.div(stress_level_age.sum(axis=1), axis=0)

# Plotting a stacked bar chart
plt.figure(figsize=(15,8))
stress_level_age.plot(kind='bar', stacked=True)
plt.title('Stress Level Distribution by Age Group')
plt.xlabel('Age')
plt.ylabel('Proportion of Stress Levels')
plt.xticks(rotation=90)
plt.legend(title='Stress Level', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

#8. What is the average technology usage per day?

avg_tech_usage = df[['Technology_Usage_Hours', 'Social_Media_Usage_Hours', 'Gaming_Hours']].mean(axis=1)
print(f"Average Technology Usage: {avg_tech_usage.mean()} hours/day")
sns.histplot(avg_tech_usage, bins=20)
plt.title('Average Technology Usage Distribution')
plt.xlabel('Average Technology Usage (Hours)')
plt.ylabel('Count')
plt.show()

#9. How is the distribution of stress levels across the dataset?

#Correlation Analysis

#10. is there a correlation between technology usage and stress level?

sns.scatterplot(x='Technology_Usage_Hours', y='Stress_Level', data=df)
plt.title('Technology Usage vs. Stress Level')
plt.xlabel('Technology Usage (Hours)')
plt.ylabel('Stress Level')
plt.show()

#11. Is there a correlation between social media usage and mental health status?

sns.scatterplot(x='Social_Media_Usage_Hours', y='Mental_Health_Status', data=df)
plt.title('Social Media Usage vs. Mental Health Status')
plt.xlabel('Social Media Usage (Hours)')
plt.ylabel('Mental Health Status')
plt.show()

#12. How does gender affect mental health status?

mental_health_by_gender = df.groupby('Gender')['Mental_Health_Status'].value_counts()
print(mental_health_by_gender)
sns.countplot(x='Gender', hue='Mental_Health_Status', data=df)
plt.title('Mental Health Status by Gender')
plt.xlabel('Gender')
plt.ylabel('Count')
plt.show()

#15. What is the average stress level by age group?

# Calculate the count of each stress level within each age group
stress_level_age = df.groupby(['Age', 'Stress_Level']).size().unstack().fillna(0)

# Normalize to get proportions
stress_level_age = stress_level_age.div(stress_level_age.sum(axis=1), axis=0)

# Plotting a stacked bar chart of stress level distribution by age
plt.figure(figsize=(20,8))
stress_level_age.plot(kind='bar', stacked=True, colormap='viridis')
plt.title('Stress Level Distribution by Age Group')
plt.xlabel('Age')
plt.ylabel('Proportion of Stress Levels')
plt.xticks(rotation=90)
plt.legend(title='Stress Level', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

#16. What is the relationship between gaming hours and stress levels?

plt.figure(figsize=(8,6))
sns.lineplot(x='Gaming_Hours', y='Stress_Level', data=df)
plt.title('Gaming Hours vs Stress Level')
plt.xlabel('Gaming Hours')
plt.ylabel('Stress Level')
plt.show()

#18.How does screen time impact mental health status?

g = sns.FacetGrid(df, col='Mental_Health_Status')
g.map(sns.kdeplot, 'Screen_Time_Hours', shade=True)
plt.subplots_adjust(top=0.9)  # Adjust spacing for title
plt.title('Distribution of Screen Time Hours by Mental Health Status')
plt.show()

#Is there a difference in social media usage between genders?

#19. Is there a difference in social media usage between genders?

avg_social_media_gender = df.groupby('Gender')['Social_Media_Usage_Hours'].mean()

plt.figure(figsize=(8,6))
sns.barplot(x=avg_social_media_gender.index, y=avg_social_media_gender.values)
plt.title('Average Social Media Usage by Gender')
plt.xlabel('Gender')
plt.ylabel('Average Social Media Usage (Hours)')
plt.show()

#What is the distribution of technology usage across different genders?

avg_tech_gender = df.groupby('Gender')['Technology_Usage_Hours'].mean()

plt.figure(figsize=(8,6))
sns.barplot(x=avg_tech_gender.index, y=avg_tech_gender.values)
plt.title('Average Technology Usage by Gender')
plt.xlabel('Gender')
plt.ylabel('Technology Usage (Hours)')
plt.show()

#How is technology usage distributed across different stress levels?

plt.figure(figsize=(10, 6))
sns.histplot(data=df, x='Technology_Usage_Hours', hue='Stress_Level', multiple='stack')
plt.title('Technology Usage Hours by Stress Level')
plt.xlabel('Technology Usage Hours')
plt.ylabel('Frequency')
plt.show()

#How does technology usage interact with gender?

fig = px.box(df, x='Gender', y='Technology_Usage_Hours', color='Gender',
             title='Technology Usage by Gender')
fig.update_layout(xaxis_title='Gender', yaxis_title='Technology Usage Hours')
fig.show()

#Is there a correlation between physical activity and mental health status?

fig = px.box(df, x='Mental_Health_Status', y='Physical_Activity_Hours', color='Mental_Health_Status',
             title='Physical Activity Hours vs Mental Health Status')
fig.update_layout(xaxis_title='Mental Health Status', yaxis_title='Physical Activity Hours')
fig.show()

#How does work environment impact mental health status?

fig = px.box(df, x='Work_Environment_Impact', y='Mental_Health_Status', color='Work_Environment_Impact',
             title='Mental Health Status by Work Environment Impact')
fig.update_layout(xaxis_title='Work Environment Impact', yaxis_title='Mental Health Status')
fig.show()

import pandas as pd
import numpy as np
from io import StringIO
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error

data = """
User_ID,Age,Gender,Technology_Usage_Hours,Social_Media_Usage_Hours,Gaming_Hours,Screen_Time_Hours,Mental_Health_Status,Stress_Level,Sleep_Hours
101,45,male,3.0,3.0,5.5,4.0,2.0,4,8
USER-00001,23,Female,6.57,6.0,0.68,12.36,Good,Low,8.01
USER-00002,21,Male,3.01,2.57,3.74,7.61,Poor,High,7.28
USER-00003,51,Male,3.04,6.14,1.26,3.16,Fair,High,8.04
USER-00004,25,Female,3.84,4.48,2.59,13.08,Excellent,Medium,5.62
USER-00005,53,Male,1.2,0.56,0.29,12.63,Good,Low,5.55
USER-00006,58,Male,5.59,5.74,0.11,1.34,Poor,Low,8.61
USER-00007,63,Female,3.38,2.55,3.79,9.78,Excellent,Medium,8.61
USER-00008,51,Female,7.18,4.1,4.74,8.14,Excellent,Medium,7.11
USER-00009,57,Other,10.86,4.11,0.08,6.02,Fair,Medium,7.19
USER-00010,31,Other,4.3,7.23,0.81,6.87,Excellent,High,5.09
USER-00011,53,Other,4.78,3.94,1.88,14.87,Poor,High,5.13
USER-00012,64,Other,4.83,4.85,1.68,13.68,Fair,Low,8.57
USER-00013,40,Female,3.06,4.06,2.54,10.65,Poor,High,7.9
USER-00014,24,Other,5.82,5.22,3.3,1.65,Excellent,High,4.82
USER-00015,38,Female,10.48,4.53,0.94,10.27,Poor,High,7.13
USER-00016,53,Male,7.51,0.21,4.17,5.08,Good,Medium,8.53
USER-00017,26,Female,6.4,5.4,4.76,11.4,Fair,High,4.62
USER-00018,55,Female,2.03,6.56,2.01,14.88,Fair,Low,8.95
USER-00019,55,Male,2.94,0.61,2.13,11.49,Excellent,High,7.71
USER-00020,37,Other,10.74,3.85,1.29,6.0,Good,Medium,5.69
"""

# Load data into a DataFrame
df = pd.read_csv(StringIO(data))

# Prepare the data for training
# Assuming the 'Mental_Health_Status' can be transformed into a score
# We'll use a simple mapping for this example
status_mapping = {
    'Excellent': 5,
    'Good': 4,
    'Fair': 3,
    'Poor': 2
}
df['Mental_Health_Score'] = df['Mental_Health_Status'].map(status_mapping)

# Features (independent variables)
X = df[['Screen_Time_Hours', 'Stress_Level', 'Sleep_Hours']]

#Purpose: This dictionary (status_mapping) is created to convert qualitative mental
#health statuses (like "Excellent," "Good," etc.) into quantitative scores.
#Explanation:
#Each mental health status category is assigned a numerical value. This allows for easier analysis and
#modeling since most machine learning algorithms work better with numerical data.
#For example, "Excellent" corresponds to a score of 5, while "Poor" corresponds to a score of 2.

#Purpose: This line applies the mapping defined in status_mapping to the Mental_Health_Status
#column in the DataFrame (df).
#Explanation:
#The .map() function replaces each value in the Mental_Health_Status column with its corresponding
#score from the status_mapping dictionary.
#A new column, Mental_Health_Score, is created in the DataFrame to store these numerical scores.
#For example, if a row in Mental_Health_Status has the value "Good," the corresponding entry in
#Mental_Health_Score will be 4.

#Defining Features (Independent Variables)
#Purpose: This line creates a new variable X that contains the features (independent variables)
#that will be used to train the model.
#Explanation:
#X is assigned the columns Screen_Time_Hours, Stress_Level, and Sleep_Hours from the DataFrame.
#These features are the predictors that the model will use to estimate or predict the Mental_Health_Score.
#Each of these variables is thought to influence mental health.

#summary
#Mapping: Convert qualitative mental health statuses (e.g., "Excellent," "Good")
#to numerical scores (5, 4) for analysis.
#Apply Mapping: Use the mapping to create a new column (Mental_Health_Score) in the DataFrame.
#Define Features: Select independent variables (Screen_Time_Hours, Stress_Level, Sleep_Hours) for model training.

# Convert Stress_Level to numeric values for modeling
stress_mapping = {
    'Low': 1,
    'Medium': 2,
    'High': 3
}
X['Stress_Level'] = X['Stress_Level'].map(stress_mapping)

# Target variable (dependent variable)
y = df['Mental_Health_Score']

#Mapping Stress Levels to Numeric Values
#Purpose: Create a mapping to convert categorical stress levels into numerical values.
#Explanation: Each stress level category ("Low," "Medium," "High") is assigned a numerical value (1, 2, 3). This transformation makes it easier for machine learning models to interpret and
#analyze the data since they typically require numerical inputs.

#Applying the Mapping
#Purpose: Replace the categorical stress level values in the feature set X with their corresponding numeric values.
#Explanation: The .map() function is applied to the Stress_Level column, transforming each category to its numerical
#counterpart. For example, "Medium" will now be represented as 2.

#Defining the Target Variable
#Purpose: Identify the target variable (dependent variable) for the model.
#Explanation: y is assigned the Mental_Health_Score column, which the model will predict based on
#the independent variables (features) in X.

#Summary
#Stress Mapping: Convert stress levels to numerical values for analysis.
#Apply Mapping: Update the Stress_Level column in X with numeric values.
#Target Variable: Define y as the Mental_Health_Score for prediction.

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)  # 80% training, 20% testing

#Splitting the Data into Training and Testing Sets
#Purpose: To divide the dataset into two subsets: one for training the model and another for testing its performance.
#Components:
#X: Features (independent variables).
#y: Target variable (dependent variable).
#train_test_split: A function from the sklearn.model_selection module that randomly splits the dataset.
#Parameters:
#test_size=0.2: Specifies that 20% of the data will be allocated for testing, while the remaining 80%
#will be used for training. This ratio helps ensure that the model has enough data to learn from while also
#allowing a separate set to evaluate its performance.
#random_state=42: Sets a seed for the random number generator, ensuring that the split is reproducible.
#Using the same random state will yield the same train/test split each time you run the code.

#summary
#This code splits the dataset into training and testing sets, with 80% of the data used for training the model and 20%
#reserved for testing its accuracy, ensuring consistent results with the specified random state.

# Create and train the model
model = LinearRegression()  # Instantiate a linear regression model
model.fit(X_train, y_train)  # Fit the model to the training data

#Step Explanation:
#Model Creation: LinearRegression() initializes a linear regression model, preparing it for training.
#Training: model.fit(X_train, y_train) trains the model using the training data, allowing it to learn how the
#features (inputs) relate to the target variable (output).
#Description of Linear Regression:
#Definition: A method that predicts a target value by finding the best-fitting straight line through the data.
#Purpose: It helps understand how changes in input variables impact the output.

#Definition: Linear regression is a statistical method used to model the relationship between one or more
#independent variables (features) and a dependent variable (target). It assumes a linear relationship, meaning
#the change in the target variable can be expressed as a linear
#combination of the independent variables.
#example - To predict outcomes: For example, predicting a person's weight based on their height.

# Convert Stress_Level to numeric values for modeling
# Apply the mapping BEFORE splitting into train and test sets

df['Stress_Level'] = df['Stress_Level'].map(stress_mapping)

#(This replaces the categorical stress levels (e.g., "Low," "Medium," "High") in the DataFrame with numeric
#values (1, 2, 3) for easier analysis.)

# Features (independent variables)
X = df[['Screen_Time_Hours', 'Stress_Level', 'Sleep_Hours']]

# Target variable (dependent variable)
y = df['Mental_Health_Score']

#X: Contains the independent variables (features) that will be used for prediction.
#y: Contains the dependent variable (target) that we want to predict.

# Check for NaN values and drop rows with NaN from both X and y
df = df.dropna(subset=['Screen_Time_Hours', 'Stress_Level', 'Sleep_Hours', 'Mental_Health_Score'])
#his removes any rows from the DataFrame that have missing values (NaN) in the specified columns
#to ensure clean data for modeling.

# Update X and y after dropping NaN rows (Not necessary since the mapping & dropna are done on df)
X = df[['Screen_Time_Hours', 'Stress_Level', 'Sleep_Hours']]
y = df['Mental_Health_Score']
#After dropping NaN rows, X and y are redefined to ensure they only include complete data.

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
#This splits the dataset into training (80%) and testing (20%) sets. The training set is used to build the model,
#while the testing set evaluates its performance. The random_state ensures the split is reproducible.

#Summary
#These steps prepare the data by converting categorical variables to numeric, defining features and the target
#variable, cleaning the dataset by removing missing values, and finally splitting the data
#into training and testing sets for modeling.

# Make predictions
y_pred = model.predict(X_test)

#Explanation:
#Purpose: This line uses the trained linear regression model to make predictions on the testing set.
#Components:
#model.predict(X_test): The predict method takes the feature set X_test (which contains the independent variables)
#as input and applies the learned linear regression equation to generate predicted values for the target variable
#(in this case, the mental health scores).
#Output:
#y_pred: This variable stores the predicted mental health scores for the samples in the X_test dataset.
#Each value in y_pred corresponds to the model's estimate of the mental health score
#based on the features provided in X_test.
#Summary
#This step generates predictions for the target variable using the trained model and the test dataset,
#allowing you to evaluate how well the model performs on unseen data.

# Evaluate the model
mse = mean_squared_error(y_test, y_pred)
print(f"Mean Squared Error: {mse:.2f}")

# Show the coefficients
print("Model Coefficients:")
print(f"Screen Time Hours Coefficient: {model.coef_[0]:.4f}")
print(f"Stress Level Coefficient: {model.coef_[1]:.4f}")
print(f"Sleep Hours Coefficient: {model.coef_[2]:.4f}")

# Predict a sample input
sample_input = np.array([[5, 2, 7]])  # Example: 5 hours of screen time, stress level 2, sleep hours 7
predicted_score = model.predict(sample_input)
print(f"Predicted Mental Health Score for the sample input: {predicted_score[0]:.2f}")

#MSE measures the average of the squares of the errors—that is,
#the average squared difference between predicted and actual values

#An MSE of 0.79 means that, on average, the model's predictions deviate from the
#actual mental health scores by a small margin. Lower values indicate better predictive accuracy,
#but the acceptability of 0.79 depends on the specific context and data range.

#2. Model Coefficients
#These coefficients represent the relationship between each independent variable
#(like screen time, stress level, and sleep hours)
#and the predicted outcome (mental health score).
#(Each coefficient indicates how much the mental health score is expected
#to change with a one-unit increase in the corresponding independent variable).

#Screen Time Hours Coefficient (-0.0124)
#This coefficient suggests the effect of screen time on mental health.
#Interpretation: For every additional hour of screen time, the mental health score decreases by about 0.0124.
#This indicates that higher screen
#time is associated with lower mental health, but the effect is minimal.

#4. Stress Level Coefficient (-0.0805)
#This coefficient reflects the impact of stress levels on mental health.
#Interpretation: For each unit increase in stress level, the mental health score decreases by
#approximately 0.0805. This shows that higher stress significantly negatively impacts mental health.

#Sleep Hours Coefficient (-0.2877)
#This coefficient indicates the relationship between sleep hours and mental health.
#Interpretation: For each additional hour of sleep, the mental health score increases by about 0.2877.
#This suggests that more sleep is strongly associated with better mental health.

#6. Predicted Mental Health Score (3.65)
#This is the outcome score predicted by the model based on the input values for screen time, stress level, and sleep hours.
#Interpretation: A score of 3.65 indicates a specific level of mental health. If higher scores represent better mental health,
#this score might suggest moderate mental health, with potential for
#improvement—especially through reducing stress and increasing sleep.

#OVERALL CONCLUSION
#Mental Health Assessment: Given the predicted score and the negative coefficients
#for screen time, stress, and sleep, it suggests that the individual in the sample input might
#be experiencing a moderate level of mental health issues. To improve their mental health score,
#they may want to consider reducing screen time, managing stress levels, and improving sleep quality.